# Rust One Piece | R1 (一)

### 开始之前

在上一篇中，我们用了 100 行左右的代码写了一个简单的解释器 R0。EOC 第二章，我们准备写一个正经的编译器了。先直观地感受一下

```sh
# 代码量为我个人的实现
syntax.rs      : 108
helper.rs      : 39
parser.rs      : 63
main.rs        : 45
compiler.rs    : 327
test.rs        : 224
---------------------
total          : 806
```

本章的重点内容集中在`syntax.rs`，`compiler.rs`中。由于内容较多，我将不会解释`test.rs`的内容，具体请参考[代码](https://github.com/siriusdemon/Rust-One-Piece/blob/master/r1/src/test.rs)。

### R1

![R1](./graphs/R1.png)

R1 跟 R0 相比，增加了变量`Var`和赋值语句`Let`。看看几个例子

```python
(let ([x (+ 12 20)]) (+ 10 x))
(let ([x 32]) (+ (let ([x 10]) x) x))
```
在 lisp 中，let 是可以并行赋值多个变量的。如
```python
(let ([x 10]
      [y 32])
  (+ x y))
```
但在本章中，let 只支持赋值一个变量，所以我把方括号去掉了，语法简化成
```python
(let (x (+ 12 10))
    (+ 10 x))
```
这样我们就不需要修改上一篇的 `parser::scan` 函数，真不错！

### 变量绑定与环境

以下内容摘自 EOC 第二章 2.1 节

「当有多个 let 嵌套赋值同个变量的时候，最里面的 let 绑定将被使用。换句话说，当前对变量的绑定会暂时覆盖前面的绑定。」 举例来说 

```python
(let ([x 32]) 
    (+ (let ([x 10]) x) # 这个 x = 10
        x))             # 这个 x = 32
```
结果为 42。确保你理解了这个例子。

嗯，这是理所当然的。但是要怎么实现呢？ 书中提供了使用关联表的方法，下面阐述的是使用嵌套哈希表的方法。具体是这样的

+ 在一开始，初始化一个空的环境（类似一个哈希表）作为当前的环境，称为 env
+ 遇到 let 语句，新建一个环境，称为 new_env，把变量和它的值记录到 new_env 中
+ 把 env 作为 new_env 的一个子环境，new_env 作为当前环境

查找变量的时候，先查找当前环境是否有这个变量，如果没有，则递归查找子环境。如果穷尽了子环境还是没有，那就说明变量不存在，否则返回变量的值。

所以，这一小节我们准备实现一个 R1 解释器，主要做以下几件事

+ 拓展语法支持变量及绑定
+ 拓展 parser 以支持变量及变量绑定
+ 定义环境 

### R1 语法
```rs
// syntax.rs
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Expr {
    Int ( i64 ),
    Var ( String ),
    Let ( Box<Expr>, Box<Expr>,  Box<Expr> ),
    Prim0 ( String ),
    Prim1 ( String, Box<Expr> ),
    Prim2 ( String, Box<Expr>, Box<Expr> ),
}
```
与 R0 相似，增加了 Var 和 Let 。

### 拓展 Parser

保持 scan 和 parse 不变，我们只需要拓展 `parse_sexpr`。现在 Atom 有两种类型了，整型和变量。所以需要判断 Atom(x) 中的 x 是否能表示一个数字。

```rs
// parser.rs
pub fn parse_sexpr(sexpr: &Sexpr) -> Expr {
    match sexpr {
        Atom(s) => if is_digit(s) { Int(s.parse().unwrap())} else { Var(s.to_string()) }
        List(v) => match v.as_slice() {
            // let expression
            [Atom(op), List(bind), exp] if op.as_str() == "let" => {
                match bind.as_slice() {
                    [Atom(var), val] if !is_digit(var) => {
                        Let( Box::new(Var(var.to_string())), Box::new(parse_sexpr(val)), Box::new(parse_sexpr(exp)) )
                    },
                    _ => panic!("variable could not be digit!"),
                }
            },
            // prim
            [Atom(op), e1, e2] if op.as_str() == "+"    => Prim2 ( string!("+"), Box::new( parse_sexpr(e1)), Box::new(parse_sexpr(e2))),
            [Atom(op), e]      if op.as_str() == "-"    => Prim1 ( string!("-"), Box::new( parse_sexpr(e))),
            [Atom(op)]         if op.as_str() == "read" => Prim0 ( string!("read")),
            _ => panic!("Invalid syntax!"),
        }
    }
}
```